	The goal of this test is to use data based evidence in order to determine the best data structure to use for a program.  The program is a hiking application which will allow users to create a profile which holds their hiking history, as well as search for information on hiking trails.  Therefore the data structures will hold UserProfile and Trail objects.
	 The necessities of the program put limitations on which data structures were plausible choices.  As there can be an indefinite number of new users and trails added to the application, it was necessary to choose a data structure which is not set in size—rather a structure which is able to expand dynamically was necessary.  This automatically ruled out HashMap and HashSet, which are fixed in size and cannot grow past the point of creation.  
	Data structures which are able to grow include Trees and Lists.  The drawback of Lists is its general poor Big O performance—although insertion is O(1), searching is linear, giving it a performance of O(N).  As searching will be an important component of the application, it is necessary to have a high search performance, ruling out Lists.  TreeSet and TreeMap were left, which have O(log N) for insertion, searching, and deletion, making them strong candidates.  As performance should be the same between TreeSet and TreeMap, it was necessary to create four instances of these data structures being applied—TreeMap and TreeSet for Trails and TreeMap and TreeSet for UserProfiles—to the application and test their performance in order to see which would be superior for this project’s needs.
	My hypothesis of the performances was that the two data structures would be nearly identical.  As they are both Tree data types, they both should have O(log N) for insertion, searching, and deletion.  The TreeMap has the benefit of being able to add nodes according to a Key, Value pair, but the TreeSet is able to be adequately organised by implementing criteria for the objects to be sorted by when the Set is created and objects are being added to it.  Thus, the TreeMap and TreeSet could be sorted in an almost identical manner.  Therefore, in order to test my hypothesis, it was necessary to set up tests within my program in order to determine performance.
	In order to test the performance of the TreeSet and TreeMap, I created two separate implementations of the data structures holding UserProfiles and Trails, giving me a total of four separate implementations—UserProfileTreeMap, UserProfileTreeSet, TrailTreeMap, and TrailTreeSet.  I then ran the data structures through a for loop in order to create incrementally larger instances of the structures filled with random Trails and UserProfiles generated by a Utilities class.  I then selected a random Trail and UserProfile in order to search for the object within the data structure.  In order to ensure true randomness of the selected object, I copied each of the data structures’ values to an array, and using the Random() method I selected the object with a random index.  Although creating the arrays would take up memory, I decided that this approach was appropriate as it would help mitigate results which could have been skewed by best case or worst case scenarios from non-random data, thus giving a false report. Each data structure was timed in performing methods such as multiple searches for a random object, removing it, and adding it again, with the time elapse recorded and added into an array in order to keep track of the times. This was repeated 10 times until the array was filled with 10 time elapsed for each of the incrementally larger sized data structures.  This array was then run through a graph using GUI in order to easily visualise which data structure had a better performance.
	Upon running the graphs, I noticed that on average the TreeMap seemed to perform faster than TreeSet for both UserProfile and Trails.  As there were less criteria to search for the UserProfile with, the methods were more balanced—one removal, one insertion, and a search by 3 different criteria, one of which was what the Trees were sorted by.  This allowed the Tree to complete most of these tasks with O(log N) performance, resulting in a more logarithmic curve of the line graph.  As the Trails had more criteria to search by (ex. name, difficulty, head address, etc.) the method was more skewed toward searching.  Additionally, as the Trees can only be sorted by one variable—in this case, TrailID—only the search by ID would have been able to maintain its O(log N) performance. The rest of the Trail criteria would have had to have been searched for linearly throughout the Tree.  As a result, I noticed that the curve for the Trail methods were more visibly linear.  
	Although Map had a tendency to outperform Set, there were many instances of near equal performance.  This aligned with my expectations—the difference between TreeMap and TreeSet is that TreeMap holds a Key, Value pair and TreeSet only holds the value.  Therefore the data structures themselves are very similar and would have a similar performance.  
	In conclusion, although the two data structures performed quite similarly, due to TreeMap’s tendency to outperform TreeSet, the TreeMap would be the logical choice of data structure for this project.